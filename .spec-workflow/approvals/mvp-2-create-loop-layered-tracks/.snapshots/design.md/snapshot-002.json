{
  "id": "snapshot_1759068948622_0dih7f75a",
  "approvalId": "approval_1759066977586_wlmkqwyis",
  "approvalTitle": "Review design for mvp-2-create-loop-layered-tracks",
  "version": 2,
  "timestamp": "2025-09-28T14:15:48.621Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Design – mvp-2-create-loop-layered-tracks\n\n## Overview\n\nExtend the loop engine so performers can overdub layered tracks onto an existing loop without stopping playback. The design expands the state machine, adds per-track storage and scheduling, and wires new transport shortcuts (pause, resume, clear) while keeping audio callbacks deterministic and low latency.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Reuse the Rust 2024 stack with `AppState`, `LoopEngine`, and CPAL audio pipeline per existing modules.\n- Maintain ≤10 ms latency and avoid XRUns under layered overdubs by keeping audio-thread work lock-free and bounded.\n- Follow spec-driven TDD: expose deterministic hooks and mockable clocks to test precise offsets.\n\n### Project Structure (structure.md)\n- Add logic to existing modules under `src/state/loop_engine.rs`, `src/app_state.rs`, `src/input.rs`, and `src/ui.rs` instead of creating new top-level directories.\n- Store tests alongside existing loop engine coverage under `tests/loop_engine/` and extend e2e specs in `tests/e2e/` to validate layered overdubs.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **LoopEngine** (`src/state/loop_engine.rs`): Extend to support overdub tracks, scheduling, and transport commands.\n- **AppState** (`src/app_state.rs`): Route new commands and maintain loop metadata displayed in the UI.\n- **AudioBus**/command queue: Reuse existing audio command channel for monitoring and scheduled playback.\n- **Input router** (`src/input.rs`): Extend key handling for Space, Control+Space, and pad events.\n- **UI transport widgets** (`src/ui.rs`): Add layered loop indicators using existing rendering patterns.\n\n### Integration Points\n- **AppState ↔ LoopEngine:** Extend the command interface with `LoopCommand::StartOverdub`, `LoopCommand::StopOverdub`, `LoopCommand::Pause`, `LoopCommand::Resume`, `LoopCommand::Clear`.\n- **AppState ↔ UI:** Publish loop status snapshots that now include track count and paused state.\n- **AppState ↔ Input:** Convert pad events to `LoopCommand::RecordEvent` during overdub sessions.\n\n## Architecture\n\nThe loop engine remains the authoritative state machine. AppState mediates user input and UI rendering by issuing commands and reading snapshots. The audio thread consumes scheduled play commands generated from loop tracks. All layered track data reside in LoopEngine, preserving a clean separation between UI/input orchestration and real-time audio logic.\n\n### Modular Design Principles\n- Loop engine file keeps lifecycle logic; new structs introduced there focus on track layering.\n- Introduce helper methods for serializing loop snapshots without leaking internal structures.\n- UI and input modules stay thin delegators, invoking new APIs while maintaining single responsibility.\n\n```mermaid\ngraph TD\n    Input[Pad/Space Input] -->|LoopCommand| AppState\n    AppState -->|Commands| LoopEngine\n    LoopEngine -->|Snapshots| AppState\n    LoopEngine -->|AudioCommand| AudioBus\n    AppState -->|Status| UI\n```\n\n## Components and Interfaces\n\n### LoopEngine (expanded)\n- **Purpose:** Manage loop lifecycle, layered track storage, scheduling, and transport controls.\n- **Interfaces:**\n  - `start_overdub(pad_event: PadEvent)` → enters recording and captures first event.\n  - `record_event(pad_event: PadEvent)` → appends to current overdub track.\n  - `commit_overdub()` → seals recording into loop tracks.\n  - `pause_loop()` / `resume_loop()` / `clear_loop()` → transport operations.\n  - `snapshot()` → returns state, active tracks, and timing metadata for UI/tests.\n- **Dependencies:** Clock abstraction, audio command sender, existing loop metadata.\n- **Reuses:** Existing Ready/Recording/Playing transitions and scheduling infrastructure.\n\n### LoopTrack struct (new)\n- **Purpose:** Represent a single overdubbed layer with precomputed schedule offsets.\n- **Interfaces:**\n  - Fields: `id`, `events: Vec<LoopEvent>`, `created_at_cycle`.\n  - Methods: `schedule_commands(base_cycle_start: Instant)` to enqueue play commands.\n- **Dependencies:** LoopEvent struct, audio command builder.\n- **Reuses:** Uses same LoopEvent structure as existing record loop feature.\n\n### AppState loop facade\n- **Purpose:** Convert user input into loop commands, persist snapshots, expose UI hooks.\n- **Interfaces:**\n  - `handle_pad_press(key)` → if overdub active, forward to loop engine; else start overdub.\n  - `handle_space()` → branch on state for pause/resume/commit/cancel.\n  - `handle_control_space()` → clear loop.\n- **Dependencies:** LoopEngine, UI state structs, input context.\n- **Reuses:** Existing transport handling from record-loop feature.\n\n### UI transport section\n- **Purpose:** Display loop state (Playing/Paused/Recording), track count, and warnings.\n- **Interfaces:**\n  - `render_loop_status(loop_snapshot)` -> draws state using ratatui widgets.\n- **Dependencies:** Ratatui components, AppState snapshot.\n- **Reuses:** Existing status badge components.\n\n## Data Models\n\n### LoopTrack\n```\npub struct LoopTrack {\n    pub id: TrackId,\n    pub events: Vec<LoopEvent>,\n    pub created_cycle: u64,\n}\n```\n\n### LoopSnapshot (extended)\n```\npub struct LoopSnapshot {\n    pub state: LoopState,\n    pub track_count: usize,\n    pub is_paused: bool,\n    pub cycle_position_ms: u128,\n    pub active_overdub: Option<OverdubSnapshot>,\n}\n```\n\n## Error Handling\n\n### Error Scenario 1 – Audio command backpressure\n- **Handling:** If the audio command channel is full, drop to error state, log via tracing, and abort overdub commit to avoid mismatched playback.\n- **User Impact:** UI shows an error badge; overdub cancels and performer must retry.\n\n### Error Scenario 2 – Invalid state transitions\n- **Handling:** Guard APIs (e.g., `start_overdub`) to return `Result` errors if called in incompatible states; AppState logs and ignores illegal input combos.\n- **User Impact:** UI maintains current state; debug log explains ignored command.\n\n## Testing Strategy\n\n### Unit Testing\n- Extend `tests/loop_engine/loop_happy_path.rs` to cover multi-track overdub scheduling.\n- Add new `loop_overdub_layers.rs` verifying precise offsets and phase alignment.\n- Test pause/resume/clear transitions in loop engine unit tests.\n\n### Integration Testing\n- Extend `tests/app_state_loop.rs` to simulate pad/space/control-space sequences producing correct snapshots and transport transitions.\n- Validate UI snapshot propagation through `tests/app_state_tests.rs`.\n\n### End-to-End Testing\n- Add e2e scenario `tests/e2e/loop_overdub_layers.test.ts` to simulate layering pads live, pausing, resuming, and clearing.\n- Extend existing loop capture e2e to ensure metronome remains silent during overdub.\n\n",
  "fileStats": {
    "size": 6708,
    "lines": 134,
    "lastModified": "2025-09-28T13:43:18.549Z"
  },
  "comments": []
}