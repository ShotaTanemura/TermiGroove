{
  "id": "snapshot_1759018690824_zhkid6i6v",
  "approvalId": "approval_1759018690797_dolz2pggj",
  "approvalTitle": "Structure steering doc for TermiGroove",
  "version": 1,
  "timestamp": "2025-09-28T00:18:10.824Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Project Structure\n\n## Directory Organization\n\n```\nTermiGroove/\n├── src/                      # Rust source (state, audio, UI, input, selection modules)\n│   ├── app_state.rs          # Global application state & focus models\n│   ├── audio.rs              # Audio engine commands, thread management, CPAL integration\n│   ├── input.rs              # Keyboard and event handling, focus routing\n│   ├── selection.rs          # File selection modeling for pads workflow\n│   ├── ui.rs                 # ratatui rendering for explorer, pads, summary/popup\n│   ├── main.rs               # Binary entrypoint wiring terminal loop\n│   └── state/                # Supporting state models (if present)\n├── tests/                    # Rust integration/unit tests and TUI e2e harness\n│   ├── app_state_tests.rs    # Unit tests for AppState behavior\n│   ├── input_handling_tests.rs\n│   ├── integration_*.rs      # Scenario tests for file navigation, pads, etc.\n│   ├── unit/                 # Additional fine-grained tests\n│   └── e2e/                  # @microsoft/tui-test scripts (.test.ts)\n├── samples/                  # Example audio files for manual testing\n├── termigroove/              # (Optional) workspace or generated artifacts\n├── Cargo.toml                # Rust crate manifest\n├── Cargo.lock                # Locked dependencies\n├── package.json              # Node scripts for e2e testing\n├── package-lock.json         # Node dependency lockfile\n├── tui-test.config.ts        # Configuration for tui-test harness\n├── .spec-workflow/           # Spec and steering docs, decision logs\n└── .cursor/                  # Automation rules and commands\n```\n\n## Naming Conventions\n\n### Files\n- Rust modules use `snake_case` (`app_state.rs`, `input_handling_tests.rs`).\n- Directories also use `snake_case` or lowercase (`state`, `tests`, `samples`).\n- Test files mirror module names with `_tests` suffix or scenario descriptors.\n\n### Code\n- **Enums/Structs**: `PascalCase` (`AppState`, `PopupFocus`).\n- **Functions/Methods**: `snake_case` (`handle_event`, `enter_pads`).\n- **Constants**: `UPPER_SNAKE_CASE` (`HELP_LINE`, `BPM_MIN`).\n- **Variables**: `snake_case` (`current_left_item`, `draft_bpm`).\n\n## Import Patterns\n\n### Import Order\n1. External crates (standard library, third-party).\n2. Internal modules via `crate::` or module path.\n3. No style imports (TUI styling handled inline).\n\n### Module/Package Organization\n- Prefer absolute crate paths (`crate::audio::AudioCommand`).\n- Cross-module access done through public methods on `AppState` rather than exposing inner fields.\n- Tests import modules with `use termigroove::*` or direct module references.\n\n## Code Structure Patterns\n\n### Module Organization\n1. Imports and use statements.\n2. Constants and helper functions.\n3. Struct/enum definitions.\n4. Core implementations (`impl` blocks) with public API first.\n5. Private helpers at bottom where needed.\n\n### Function Organization\n- Validate input/state early (e.g., selection checks in `enter_pads`).\n- Update state via dedicated setters to maintain invariants (BPM, bars clamp).\n- Emit audio/UI commands after state mutation.\n- Return `Result` with context via `anyhow` when operations may fail.\n\n### File Organization Principles\n- One primary component per file (state, input, UI, audio separated).\n- Keep UI rendering logic in `ui.rs`; avoid mixing with state transitions.\n- Tests colocated by concern (AppState tests interact with state behaviors only).\n\n## Code Organization Principles\n1. **Single Responsibility**: Each module owns a distinct concern (state vs UI vs audio).\n2. **Separation of Concerns**: Input handlers mutate `AppState`; UI reads from state.\n3. **Testability**: Public getters/setters enable unit and integration testing without UI coupling.\n4. **Predictability**: Clamping and validation centralized to avoid duplicated logic.\n\n## Module Boundaries\n- `AppState` is the central source of truth; other modules depend on it via public APIs.\n- `audio` module only receives commands, never directly reads UI state.\n- `ui` module renders based on read-only state access; no side effects.\n- `input` owns translating events into state mutations and audio commands.\n- Tests may mock or simulate audio via channel senders, keeping coupling low.\n\n## Code Size Guidelines\n- Aim to keep modules under ~400 lines; split when adding major features.\n- Functions ideally ≤50 lines; refactor lengthy logic into helpers.\n- Limit enum variants to what is necessary; prefer compositional state over deep nesting.\n\n## Dashboard/Monitoring Structure (if applicable)\n- TUI dashboard components live in `ui.rs`; summary boxes and popups use dedicated rendering functions.\n- No separate dashboard subsystem yet; future remote/analytics components would reside under `src/ui/` submodules or dedicated directories.\n\n## Documentation Standards\n- Public-facing enums and structs documented when behavior is non-obvious.\n- Complex focus or input flows warrant inline comments near state transitions.\n- Steering/spec documents maintained under `.spec-workflow/` with decision logs updated per feature.\n",
  "fileStats": {
    "size": 5263,
    "lines": 103,
    "lastModified": "2025-09-28T00:17:29.254Z"
  },
  "comments": []
}