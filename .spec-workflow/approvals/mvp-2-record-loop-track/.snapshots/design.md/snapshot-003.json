{
  "id": "snapshot_1759027403027_syuogdyoc",
  "approvalId": "approval_1759027085651_utkfs4tuo",
  "approvalTitle": "Design v2 for mvp-2-record-loop-track",
  "version": 3,
  "timestamp": "2025-09-28T02:43:23.027Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design – mvp-2-record-loop-track\n\n## Overview\nImplement a loop recording subsystem that extends `AppState` with a dedicated `LoopEngine`. The engine manages the `Idle → Ready → Recording → Playing` lifecycle, coordinates with the audio thread for monitoring (live pad playback) and scheduled loop playback, and retains captured loops only while they remain valid for the current BPM/bars within the running session. Input handlers (space key in Pads mode) delegate to the engine, and UI observes read-only state for minimal, scope-appropriate feedback (status text, not new widgets).\n\n### Goals\n- Deterministic timing using a mockable clock so TDD can assert lifecycle transitions and precise offsets.\n- Hard-real-time safety: recording and playback must not block the audio callback or the main event loop.\n- Loop retention while valid: keep captured events in memory for seamless playback, but clear them when canceled or when BPM/bars change so outdated loops never linger.\n\n### Non-Goals (per requirements)\n- No new timeline visualization or transport UI enhancements beyond existing status messaging.\n- No overdubbing/multi-layer mixing beyond replaying the single captured cycle.\n- No BPM/bars editing UI changes (handled by prior spec).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Keep audio operations asynchronous using CPAL; avoid blocking the callback thread.\n- Maintain sub-10ms input-to-audio latency by continuing to send `AudioCommand::Play` for immediate monitoring.\n- Pre-allocate buffers and use lock-free queues where possible to prevent XRuns.\n\n### Project Structure (structure.md)\n- Introduce `src/state/loop_engine.rs` for the new engine module, keeping `AppState` lean.\n- Extend `src/audio.rs` with new commands for metronome ticks and scheduled playback, preserving modular boundaries.\n- Keep loop data entirely in engine state; no new persistence helpers required.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`AppState`**: orchestrates mode/focus; will own a `LoopEngine` instance and expose read-only getters.\n- **`AudioCommand`**: extend with `MetronomeTick` and `PlayScheduled { event_id }` variants to reuse existing audio thread infrastructure.\n- **`input.rs`**: reuse event dispatch to translate Space key into engine calls.\n- **`selection` & pads mapping**: reuse existing pad-to-sample mapping for monitoring playback.\n\n### Integration Points\n- **Audio thread (`audio.rs`)**: extend to handle metronome ticks (synthesized beep) and scheduled loop playback using timers or sink start offsets.\n\n## Architecture\n\n### LoopEngine Module\n- Holds state (`LoopState`, `events`, `loop_length_ms`, `start_time`) and implements methods: `enter_ready`, `cancel_ready`, `start_recording`, `cancel_recording`, `complete_recording`, `tick_playback`.\n- Depends on a `Clock` trait abstraction with `now()` returning `Instant`-like value; production implementation wraps `std::time::Instant`, tests use a fake clock.\n- Communicates with audio via an injected `AudioBus` trait that wraps the `Sender<AudioCommand>` but allows mocking in tests.\n\n### Timing & Scheduling\n- During recording, `LoopEngine` records events by calling `clock.now()` and storing offsets relative to `record_start`.\n- Playback scheduling occurs in the main loop: on each frame/tick, `LoopEngine::collect_due_events(now)` returns events to emit via `AudioCommand::Play` (immediate) while also scheduling future occurrences by tracking `last_cycle_start`.\n- Metronome ticks are produced by generating a short synthesized beep per tick (no preloaded asset) via `AudioCommand::PlayMetronome`, using rodio primitives to create a brief sine wave or square pulse on demand.\n\n### Loop Reset Behavior\n- When BPM or bars change, the engine clears its in-memory events and returns to `Idle`, forcing a fresh recording for the new tempo context.\n- On application start (AppState::new), the engine begins empty (`Idle`) with no prior loop data carried over from previous runs.\n\n### Error Handling\n- Audio command failures fall back to logging; the engine keeps state consistent.\n\n### Modular Design Principles\n- **Single Responsibility**: `LoopEngine` handles loop lifecycle and in-memory loop data; `AudioBus` handles command dispatch.\n- **Component Isolation**: no UI logic in engine; UI module reads simple enums/flags.\n- **Utility Modularity**: helpers like `compute_loop_length_ms(bpm, bars)` live in `loop_engine.rs` but are exported for tests.\n\n```mermaid\ngraph TD\n    InputSpace[Space Key Event] -->|input.rs| EngineCall[AppState::loop_engine.handle_space]\n    EngineCall --> LoopEngine\n    LoopEngine -->|AudioCommand| AudioThread\n    AudioThread -->|Play| Speakers\n    LoopEngine -->|State Snapshot| AppState\n    AppState -->|status text| UI\n```\n\n## Components and Interfaces\n\n### Component 1 – `LoopEngine`\n- **Purpose:** Own loop lifecycle, capture events, schedule playback, maintain in-memory loop, and expose read-only state.\n- **Interfaces:**\n  - `fn new(clock: Box<dyn Clock>, audio: Box<dyn AudioBus>) -> Self`\n  - `fn handle_space(&mut self, bpm: u16, bars: u16)` – orchestrates transitions depending on current state.\n  - `fn record_event(&mut self, pad: char)` – called by input when pad triggered during recording.\n  - `fn update(&mut self)` – invoked each frame to schedule playback events.\n  - `fn state(&self) -> LoopState` – returns enum for UI/testing.\n- **Dependencies:** `Clock`, `AudioBus`.\n- **Reuses:** util functions for clamping, `AudioCommand` channel, existing pad mapping.\n\n### Component 2 – `AudioBus` (trait + impl)\n- **Purpose:** Abstract the `Sender<AudioCommand>` with non-blocking semantics and provide helpers for pad playback, synthesized metronome beeps, and scheduled events.\n- **Interfaces:** `fn play_pad(&self, key: char)`, `fn play_metronome_beep(&self)`, `fn play_scheduled(&self, event: &RecordedEvent)`.\n- **Dependencies:** existing audio thread; metronome beep synthesized on demand via rodio primitives (e.g., short sine burst).\n- **Reuses:** new audio commands for metronome & scheduled playback, existing immediate playback path.\n\n### Component 3 – `Clock` (trait + impl)\n- **Purpose:** Provide deterministic time for engine.\n- **Interfaces:** `fn now(&self) -> Duration`, `fn sleep_until(&self, instant: Duration)` (testing only).\n- **Dependencies:** `std::time::Instant` in production; `FakeClock` in tests.\n\n## Data Models\n\n### LoopState Enum\n```\npub enum LoopState {\n    Idle,\n    Ready { countdown_ticks_remaining: u8 },\n    Recording { started_at: Duration },\n    Playing { cycle_started_at: Duration },\n}\n```\n\n### RecordedEvent Struct\n```\npub struct RecordedEvent {\n    pub pad: char,\n    pub offset_ms: u32,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Metronome synthesis failure**\n   - **Handling:** Log warning; skip tick but keep lifecycle transitions intact.\n   - **User Impact:** Performer loses the audio countdown cue, yet Ready/Recording state changes still occur.\n\n2. **Audio channel disconnect**\n   - **Handling:** Engine marks itself `Idle` and clears events to avoid replaying incomplete loops.\n   - **User Impact:** Recording stops; user must restart the session.\n\n## Testing Strategy\n\n### Unit Testing\n- Test `LoopEngine::handle_space` transitions for all states using `FakeClock` to control time.\n- Verify `record_event` stores offsets correctly for varied pad timings.\n- Validate metronome countdown emits four `PlayMetronome` commands at expected intervals.\n\n### Integration Testing\n- Extend `tests/app_state_tests.rs` with scenarios: pressing Space sequences states and interacts with `AudioBusMock`.\n- Integration test using `spawn_audio_thread` mocked by channel to confirm scheduled playback commands align with offsets.\n\n### End-to-End Testing\n- Add TUI test workflow (using @microsoft/tui-test) that simulates: enter Pads, press Space, trigger pads, wait for loop playback.\n\n",
  "fileStats": {
    "size": 7916,
    "lines": 142,
    "lastModified": "2025-09-28T02:38:22.618Z"
  },
  "comments": []
}