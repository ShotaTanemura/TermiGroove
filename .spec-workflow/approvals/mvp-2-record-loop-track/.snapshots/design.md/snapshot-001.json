{
  "id": "snapshot_1759026152252_rtdrmfq5t",
  "approvalId": "approval_1759026152244_9m97alr70",
  "approvalTitle": "Design draft for mvp-2-record-loop-track",
  "version": 1,
  "timestamp": "2025-09-28T02:22:32.252Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design – mvp-2-record-loop-track\n\n## Overview\nImplement a loop recording subsystem that extends `AppState` with a dedicated `LoopEngine`. The engine manages the `Idle → Ready → Recording → Playing` lifecycle, coordinates with the audio thread for monitoring (live pad playback) and scheduled loop playback, and persists captured loops to disk between sessions. Input handlers (space key in Pads mode) delegate to the engine, and UI observes read-only state for minimal, scope-appropriate feedback (status text, not new widgets).\n\n### Goals\n- Deterministic timing using a mockable clock so TDD can assert lifecycle transitions and precise offsets.\n- Hard-real-time safety: recording and playback must not block the audio callback or the main event loop.\n- Loop persistence: save loop events to disk in a simple binary/JSON format and reload on startup.\n\n### Non-Goals (per requirements)\n- No new timeline visualization or transport UI enhancements beyond existing status messaging.\n- No overdubbing/multi-layer mixing beyond replaying the single captured cycle.\n- No BPM/bars editing UI changes (handled by prior spec).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Keep audio operations asynchronous using CPAL; avoid blocking the callback thread.\n- Maintain sub-10ms input-to-audio latency by continuing to send `AudioCommand::Play` for immediate monitoring.\n- Pre-allocate buffers and use lock-free queues where possible to prevent XRuns.\n\n### Project Structure (structure.md)\n- Introduce `src/state/loop_engine.rs` for the new engine module, keeping `AppState` lean.\n- Extend `src/audio.rs` with new commands for metronome ticks and scheduled playback, preserving modular boundaries.\n- Persist data via a new helper under `src/state/loop_storage.rs` to follow single-responsibility.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`AppState`**: orchestrates mode/focus; will own a `LoopEngine` instance and expose read-only getters.\n- **`AudioCommand`**: extend with `MetronomeTick` and `PlayScheduled { event_id }` variants to reuse existing audio thread infrastructure.\n- **`input.rs`**: reuse event dispatch to translate Space key into engine calls.\n- **`selection` & pads mapping**: reuse existing pad-to-sample mapping for monitoring playback.\n\n### Integration Points\n- **Audio thread (`audio.rs`)**: extend to handle metronome ticks (short sample or synthesized click) and scheduled loop playback using timers or sink start offsets.\n- **Persistence**: add simple JSON file under `~/.config/termigroove/loops/current_loop.json` (configurable) using `serde` to serialize `RecordedEvent` structs.\n\n## Architecture\n\n### LoopEngine Module\n- Holds state (`LoopState`, `events`, `loop_length_ms`, `start_time`) and implements methods: `enter_ready`, `cancel_ready`, `start_recording`, `cancel_recording`, `complete_recording`, `tick_playback`.\n- Depends on a `Clock` trait abstraction with `now()` returning `Instant`-like value; production implementation wraps `std::time::Instant`, tests use a fake clock.\n- Communicates with audio via an injected `AudioBus` trait that wraps the `Sender<AudioCommand>` but allows mocking in tests.\n\n### Timing & Scheduling\n- During recording, `LoopEngine` records events by calling `clock.now()` and storing offsets relative to `record_start`.\n- Playback scheduling occurs in the main loop: on each frame/tick, `LoopEngine::collect_due_events(now)` returns events to emit via `AudioCommand::Play` (immediate) while also scheduling future occurrences by tracking `last_cycle_start`.\n- Metronome ticks are emitted using a preloaded sample or generated short beep; four ticks triggered via `AudioCommand::PlayMetronome` spaced by `clock.interval_from_bpm(bpm)`.\n\n### Persistence\n- After each successful recording, serialize `LoopSnapshot { bpm, bars, events }` to disk.\n- On application start (AppState::new), load existing snapshot if BPM/bars match current configuration; otherwise prompt re-record (per requirements, playing a stale loop after tempo change is not supported).\n\n### Error Handling\n- If persistence read/write fails, log via `anyhow` context but keep runtime functional (loop simply doesn’t restore).\n- Audio command failures fall back to logging; the engine keeps state consistent.\n\n### Modular Design Principles\n- **Single Responsibility**: `LoopEngine` handles loop lifecycle; `LoopStorage` handles persistence; `AudioBus` handles command dispatch.\n- **Component Isolation**: no UI logic in engine; UI module reads simple enums/flags.\n- **Utility Modularity**: helpers like `compute_loop_length_ms(bpm, bars)` live in `loop_engine.rs` but are exported for tests.\n\n```mermaid\ngraph TD\n    InputSpace[Space Key Event] -->|input.rs| EngineCall[AppState::loop_engine.handle_space]\n    EngineCall --> LoopEngine\n    LoopEngine -->|AudioCommand| AudioThread\n    LoopEngine -->|Persist Snapshot| LoopStorage\n    AudioThread -->|Play| Speakers\n    LoopEngine -->|State Snapshot| AppState\n    AppState -->|status text| UI\n```\n\n## Components and Interfaces\n\n### Component 1 – `LoopEngine`\n- **Purpose:** Own loop lifecycle, capture events, schedule playback, and expose read-only state.\n- **Interfaces:**\n  - `fn new(clock: Box<dyn Clock>, audio: Box<dyn AudioBus>) -> Self`\n  - `fn handle_space(&mut self, bpm: u16, bars: u16)` – orchestrates transitions depending on current state.\n  - `fn record_event(&mut self, pad: char)` – called by input when pad triggered during recording.\n  - `fn update(&mut self)` – invoked each frame to schedule playback events.\n  - `fn state(&self) -> LoopState` – returns enum for UI/testing.\n- **Dependencies:** `Clock`, `AudioBus`, `LoopStorage` (optional injected trait for persistence operations).\n- **Reuses:** util functions for clamping, `AudioCommand` channel.\n\n### Component 2 – `LoopStorage`\n- **Purpose:** Persist/load loop snapshots to/from disk, ensuring durability across restarts.\n- **Interfaces:** `fn load() -> anyhow::Result<Option<LoopSnapshot>>`, `fn save(snapshot: &LoopSnapshot) -> anyhow::Result<()>`, `fn reset() -> anyhow::Result<()>`.\n- **Dependencies:** `std::fs`, `serde_json`, optional `dirs` crate for config path.\n- **Reuses:** `LoopSnapshot` struct defined in engine module.\n\n### Component 3 – `AudioBus` (trait + impl)\n- **Purpose:** Abstract the `Sender<AudioCommand>` with non-blocking semantics and preloading of metronome sample.\n- **Interfaces:** `fn play_pad(&self, key: char)`, `fn play_metronome(&self)`, `fn play_scheduled(&self, event: &RecordedEvent)`.\n- **Dependencies:** existing audio thread, newly preloaded metronome sample.\n- **Reuses:** uses new audio commands for metronome & scheduled playback.\n\n### Component 4 – `Clock` (trait + impl)\n- **Purpose:** Provide deterministic time for engine.\n- **Interfaces:** `fn now(&self) -> Duration`, `fn sleep_until(&self, instant: Duration)` (testing only).\n- **Dependencies:** `std::time::Instant` in production; `FakeClock` in tests.\n\n## Data Models\n\n### LoopState Enum\n```\npub enum LoopState {\n    Idle,\n    Ready { countdown_ticks_remaining: u8 },\n    Recording { started_at: Duration },\n    Playing { cycle_started_at: Duration },\n}\n```\n\n### RecordedEvent Struct\n```\npub struct RecordedEvent {\n    pub pad: char,\n    pub offset_ms: u32,\n}\n```\n\n### LoopSnapshot Struct\n```\npub struct LoopSnapshot {\n    pub bpm: u16,\n    pub bars: u16,\n    pub events: Vec<RecordedEvent>,\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Metronome sample missing**\n   - **Handling:** Log warning; fall back to synthesizing a tick via rodio sine wave generator.\n   - **User Impact:** Metronome may sound different but recording still works.\n\n2. **Persistence failure (disk full/permission)**\n   - **Handling:** Surface status message “Loop not saved” and keep in-memory events until next reset.\n   - **User Impact:** Loop doesn’t restore next run; functionality unaffected this session.\n\n3. **Audio channel disconnect**\n   - **Handling:** Engine marks itself `Idle` and clears events to avoid replaying incomplete loops.\n   - **User Impact:** Recording stops; user must restart the session.\n\n## Testing Strategy\n\n### Unit Testing\n- Test `LoopEngine::handle_space` transitions for all states using `FakeClock` to control time.\n- Verify `record_event` stores offsets correctly for varied pad timings.\n- Ensure persistence serialization/deserialization retains data integrity.\n- Validate metronome countdown emits four tick commands at expected intervals.\n\n### Integration Testing\n- Extend `tests/app_state_tests.rs` with scenarios: pressing Space sequences states and interacts with `AudioBusMock`.\n- Add tests ensuring loop reload on startup when snapshot exists and matches BPM/bars.\n- Integration test using `spawn_audio_thread` mocked by channel to confirm scheduled playback commands align with offsets.\n\n### End-to-End Testing\n- Add TUI test workflow (using @microsoft/tui-test) that simulates: enter Pads, press Space, trigger pads, wait for loop playback.\n- Validate persistence by restarting the app between runs in a scripted e2e scenario (if feasible) or simulating via separate process invocation.\n\n",
  "fileStats": {
    "size": 9141,
    "lines": 167,
    "lastModified": "2025-09-28T02:22:05.404Z"
  },
  "comments": []
}